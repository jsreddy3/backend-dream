#!/usr/bin/env python3
"""
JSV-428 PROOF OF FIX TEST
=========================
This test proves that our JSV-428 fixes actually work by:
1. Simulating the exact conditions that caused database deadlocks
2. Running concurrent operations that would previously fail
3. Measuring database session duration improvements
4. Verifying external calls no longer block the database
"""

import asyncio
import time
import threading
from datetime import datetime
from uuid import uuid4
from concurrent.futures import ThreadPoolExecutor
from unittest.mock import AsyncMock, patch
import os
import sys

# Add the backend to path
sys.path.insert(0, 'new_backend_ruminate')

class DatabaseSessionTracker:
    """Track database session usage patterns"""
    def __init__(self):
        self.sessions = {}
        self.session_durations = []
        self.concurrent_sessions = 0
        self.max_concurrent = 0
        self.lock = threading.Lock()
    
    def session_opened(self, session_id, operation):
        with self.lock:
            self.sessions[session_id] = {
                'operation': operation,
                'start_time': time.time(),
                'thread_id': threading.get_ident()
            }
            self.concurrent_sessions += 1
            self.max_concurrent = max(self.max_concurrent, self.concurrent_sessions)
            print(f"üìä Session {session_id[:8]} opened for {operation} (concurrent: {self.concurrent_sessions})")
    
    def session_closed(self, session_id):
        with self.lock:
            if session_id in self.sessions:
                session_info = self.sessions[session_id] 
                duration = time.time() - session_info['start_time']
                self.session_durations.append(duration)
                self.concurrent_sessions -= 1
                print(f"üìä Session {session_id[:8]} closed after {duration:.2f}s (concurrent: {self.concurrent_sessions})")
                del self.sessions[session_id]
    
    def get_stats(self):
        with self.lock:
            if not self.session_durations:
                return {
                    'avg_duration': 0,
                    'max_duration': 0,
                    'max_concurrent': self.max_concurrent,
                    'total_sessions': 0
                }
            return {
                'avg_duration': sum(self.session_durations) / len(self.session_durations),
                'max_duration': max(self.session_durations),
                'max_concurrent': self.max_concurrent,
                'total_sessions': len(self.session_durations)
            }

# Global session tracker
session_tracker = DatabaseSessionTracker()

class MockLLMService:
    """Mock LLM that simulates realistic API call delays"""
    def __init__(self, delay_seconds=2.0):
        self.delay_seconds = delay_seconds
        self.calls_made = 0
    
    async def generate_structured_response(self, messages, response_format=None, json_schema=None):
        self.calls_made += 1
        print(f"ü§ñ LLM Call #{self.calls_made} started (will take {self.delay_seconds}s)")
        await asyncio.sleep(self.delay_seconds)
        print(f"ü§ñ LLM Call #{self.calls_made} completed")
        return {
            "title": f"Dream Title {self.calls_made}",
            "summary": f"Dream summary generated by call #{self.calls_made}"
        }
    
    async def generate_response(self, messages):
        self.calls_made += 1
        print(f"üß† Analysis Call #{self.calls_made} started (will take {self.delay_seconds}s)")
        await asyncio.sleep(self.delay_seconds)
        print(f"üß† Analysis Call #{self.calls_made} completed")
        return f"Analysis result from call #{self.calls_made}"

class MockTranscriptionService:
    """Mock transcription service with realistic delays"""
    def __init__(self, delay_seconds=1.5):
        self.delay_seconds = delay_seconds
        self.calls_made = 0
    
    async def transcribe(self, audio_url):
        self.calls_made += 1
        print(f"üéôÔ∏è Transcription Call #{self.calls_made} started (will take {self.delay_seconds}s)")
        await asyncio.sleep(self.delay_seconds)
        print(f"üéôÔ∏è Transcription Call #{self.calls_made} completed")
        return f"Transcribed text from call #{self.calls_made}: I was flying in my dream."

class MockDreamRepository:
    """Mock repository that tracks database session usage"""
    def __init__(self):
        self.dreams = {}
        self.segments = {}
    
    async def get_dream(self, user_id, dream_id, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "get_dream")
        
        # Simulate database query time
        await asyncio.sleep(0.01)
        
        dream = self.dreams.get(dream_id, {
            'id': dream_id,
            'user_id': user_id,
            'transcript': 'Test dream transcript',
            'title': None,
            'summary': None,
            'analysis': None
        })
        
        session_tracker.session_closed(session_id)
        return dream
    
    async def update_title_and_summary(self, user_id, dream_id, title, summary, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_title_summary")
        
        # Simulate database write time
        await asyncio.sleep(0.02)
        
        if dream_id not in self.dreams:
            self.dreams[dream_id] = {}
        
        self.dreams[dream_id].update({
            'title': title,
            'summary': summary
        })
        
        session_tracker.session_closed(session_id)
        return self.dreams[dream_id]
    
    async def update_analysis(self, user_id, dream_id, analysis, metadata, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_analysis")
        
        await asyncio.sleep(0.02)
        
        if dream_id not in self.dreams:
            self.dreams[dream_id] = {}
            
        self.dreams[dream_id]['analysis'] = analysis
        
        session_tracker.session_closed(session_id)
        return self.dreams[dream_id]
    
    async def update_segment_transcript(self, user_id, dream_id, segment_id, transcript, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_segment_transcript") 
        
        await asyncio.sleep(0.02)
        
        self.segments[segment_id] = transcript
        
        session_tracker.session_closed(session_id)
    
    # Add other required methods with similar tracking
    async def update_summary_status(self, user_id, dream_id, status, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_summary_status")
        await asyncio.sleep(0.01)
        session_tracker.session_closed(session_id)
    
    async def update_analysis_status(self, user_id, dream_id, status, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_analysis_status")
        await asyncio.sleep(0.01)
        session_tracker.session_closed(session_id)
    
    async def update_segment_transcription_status(self, user_id, dream_id, segment_id, status, session):
        session_id = str(id(session))
        session_tracker.session_opened(session_id, "update_segment_status")
        await asyncio.sleep(0.01)
        session_tracker.session_closed(session_id)

class MockStorageService:
    """Mock S3 storage service"""
    async def generate_presigned_get(self, dream_id, filename):
        return ("test_key", f"https://test-url/{filename}")

async def mock_session_scope():
    """Mock session scope that tracks usage"""
    class MockSession:
        def __init__(self):
            self.id = str(uuid4())
            
        async def commit(self):
            pass
            
        async def rollback(self):
            pass
            
        async def close(self):
            pass
    
    session = MockSession()
    try:
        yield session
    finally:
        pass

async def test_concurrent_dream_operations():
    """Test that multiple dream operations can run concurrently without deadlocks"""
    print("\nüß™ TEST 1: Concurrent Dream Operations")
    print("=" * 50)
    
    # Reset tracker
    global session_tracker
    session_tracker = DatabaseSessionTracker()
    
    # Create mock services with realistic delays
    mock_llm = MockLLMService(delay_seconds=2.0)  # 2 second LLM calls
    mock_repo = MockDreamRepository()
    
    # Import the dream service after setting up mocks
    with patch('new_backend_ruminate.services.dream.service.session_scope', mock_session_scope), \
         patch('new_backend_ruminate.infrastructure.db.bootstrap.session_scope', mock_session_scope):
        
        from new_backend_ruminate.services.dream.service import DreamService
        
        # Create dream service with mocks
        service = DreamService(
            dream_repo=mock_repo,
            storage=MockStorageService(),
            user_repo=None,
            transcription_service=MockTranscriptionService(),
            hub=None,
            summary_llm=mock_llm,
            question_llm=mock_llm,
            analysis_llm=mock_llm
        )
        
        # Test concurrent operations on same dream (this would cause deadlocks before)
        dream_id = uuid4()
        user_id = uuid4()
        
        print(f"üéØ Testing concurrent operations on dream {str(dream_id)[:8]}")
        
        start_time = time.time()
        
        # Run 3 operations concurrently that would previously deadlock
        tasks = [
            service.generate_title_and_summary(user_id, dream_id),
            service.generate_analysis(user_id, dream_id),
            service.transcribe_segment_and_store(user_id, dream_id, uuid4(), "test.m4a")
        ]
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        total_time = time.time() - start_time
        stats = session_tracker.get_stats()
        
        print(f"\nüìä RESULTS:")
        print(f"  Total Time: {total_time:.2f}s")
        print(f"  Max Concurrent Sessions: {stats['max_concurrent']}")
        print(f"  Average Session Duration: {stats['avg_duration']:.3f}s")
        print(f"  Max Session Duration: {stats['max_duration']:.3f}s")
        print(f"  Total Sessions Created: {stats['total_sessions']}")
        
        # Verify no exceptions occurred
        exceptions = [r for r in results if isinstance(r, Exception)]
        if exceptions:
            print(f"‚ùå FAILED: {len(exceptions)} operations failed with exceptions")
            for e in exceptions:
                print(f"   {type(e).__name__}: {e}")
            return False
        else:
            print("‚úÖ SUCCESS: All concurrent operations completed without deadlocks")
            
        # Verify performance improvement (sessions should be short)
        if stats['max_duration'] < 0.5:  # Less than 500ms
            print("‚úÖ SUCCESS: Database sessions are short-lived (<500ms)")
        else:
            print(f"‚ö†Ô∏è  WARNING: Some sessions took longer than expected ({stats['max_duration']:.3f}s)")
            
        return True

async def test_external_calls_dont_block_database():
    """Test that external API calls don't hold database sessions open"""
    print("\nüß™ TEST 2: External Calls Don't Block Database")
    print("=" * 50)
    
    # Reset tracker
    global session_tracker
    session_tracker = DatabaseSessionTracker()
    
    # Create mock with longer delay to test blocking
    mock_llm = MockLLMService(delay_seconds=3.0)  # 3 second delay
    mock_repo = MockDreamRepository()
    
    with patch('new_backend_ruminate.services.dream.service.session_scope', mock_session_scope), \
         patch('new_backend_ruminate.infrastructure.db.bootstrap.session_scope', mock_session_scope):
        
        from new_backend_ruminate.services.dream.service import DreamService
        
        service = DreamService(
            dream_repo=mock_repo,
            storage=MockStorageService(),
            user_repo=None,
            transcription_service=MockTranscriptionService(delay_seconds=3.0),
            hub=None,
            summary_llm=mock_llm,
            question_llm=mock_llm,
            analysis_llm=mock_llm
        )
        
        dream_id = uuid4()
        user_id = uuid4()
        
        print(f"üéØ Testing that 3-second LLM calls don't block database")
        
        # Start a long-running operation
        task1 = asyncio.create_task(service.generate_title_and_summary(user_id, dream_id))
        
        # Wait a bit, then start another operation that should NOT be blocked
        await asyncio.sleep(0.5)
        task2 = asyncio.create_task(service.generate_analysis(user_id, uuid4()))  # Different dream
        
        # Both should complete without the second being blocked by the first
        start_time = time.time()
        results = await asyncio.gather(task1, task2, return_exceptions=True)
        total_time = time.time() - start_time
        
        stats = session_tracker.get_stats()
        
        print(f"\nüìä RESULTS:")
        print(f"  Total Time: {total_time:.2f}s")
        print(f"  Max Concurrent Sessions: {stats['max_concurrent']}")
        print(f"  Average Session Duration: {stats['avg_duration']:.3f}s")
        print(f"  Max Session Duration: {stats['max_duration']:.3f}s")
        
        # The key test: session duration should be much shorter than total operation time
        if stats['max_duration'] < 1.0 and total_time > 3.0:
            print("‚úÖ SUCCESS: External calls don't hold database sessions open")
            print(f"  üìà Improvement: Sessions {total_time/stats['max_duration']:.1f}x shorter than operation time")
            return True
        else:
            print("‚ùå FAILED: Database sessions are still being held during external calls")
            return False

async def test_database_timeout_configuration():
    """Test that database timeouts are properly configured"""
    print("\nüß™ TEST 3: Database Timeout Configuration")
    print("=" * 50)
    
    try:
        # Test that we can import and initialize the database with timeouts
        from new_backend_ruminate.infrastructure.db.bootstrap import init_engine
        from new_backend_ruminate.config import settings
        
        # This should work with our timeout configuration
        await init_engine(settings())
        print("‚úÖ SUCCESS: Database engine initialized with timeout configuration")
        
        # Verify timeout settings are in the engine configuration
        from new_backend_ruminate.infrastructure.db.bootstrap import engine
        if engine and hasattr(engine, 'pool'):
            print(f"‚úÖ SUCCESS: Engine pool timeout configured: {getattr(engine.pool, '_timeout', 'Unknown')}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå FAILED: Database timeout configuration error: {e}")
        return False

async def run_comprehensive_validation():
    """Run all JSV-428 validation tests"""
    print("üî¨ JSV-428 COMPREHENSIVE VALIDATION")
    print("=" * 60)
    print("Testing that our fixes actually solve the database deadlock problem")
    print("=" * 60)
    
    tests_passed = 0
    total_tests = 3
    
    # Test 1: Concurrent Operations
    if await test_concurrent_dream_operations():
        tests_passed += 1
    
    # Test 2: External Call Blocking
    if await test_external_calls_dont_block_database():  
        tests_passed += 1
        
    # Test 3: Database Configuration
    if await test_database_timeout_configuration():
        tests_passed += 1
    
    print("\n" + "=" * 60)
    print(f"üìä FINAL RESULTS: {tests_passed}/{total_tests} tests passed")
    
    if tests_passed == total_tests:
        print("üéâ JSV-428 FIX VERIFIED - Database deadlock issue is SOLVED!")
        print("‚úÖ External API calls no longer block database sessions")
        print("‚úÖ Concurrent operations work without deadlocks")
        print("‚úÖ Database timeouts are properly configured")
        print("üöÄ Ready for production deployment!")
        return True
    else:
        print("‚ùå JSV-428 FIX INCOMPLETE - Some issues remain")
        return False

if __name__ == "__main__":
    success = asyncio.run(run_comprehensive_validation())
    exit(0 if success else 1)